#include<bits/stdc++.h>
using namespace std;
const double eps = 1e-6;
#define ll int
typedef long double ld;
#define pb push_back // for vector
#define pi pair 
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define ff first
#define ss second
#define vt vector
#define vi vt<ll>

#define repr(i, n, a) for (ll i = n; i >= a; i--)
#define dq deque
#define inset(a, st) st.find(a) != st.end()
#define issub(a, b) b.find(a) != string::npos // check if a is substr of b
#define len(a) (ll)a.size()
const ld PI = 2 * acos(0.0);
const ll mod1 = 1e9+7;
const ll mod = 998244353;
const ll nax = 2e5 + 5;
const ll LIM = 8e5+50;
const ll N = 5e3+1;
void ff(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
}

ll tim = 0, label = 0;
vt<ll>timerin , timerout, labels, labelsr, parent;
vt<ll>seg;


ll build(ll l , ll r, ll i , vt<ll>&a){
  if(l == r){
   return seg[i] = a[labelsr[l]];
  }
  ll mid = l + (r-l)/2;
  ll val1 = build(l , mid , 2*i , a);
  ll val2 = build(mid+1, r , 2*i+1, a);
  return seg[i] = max(val1 , val2);
}
 
ll query(ll l , ll r, ll i, ll a , ll b){
  if(l>=a && r <= b ){
    return seg[i];
  }
  if(l > b || r < a){
    return -1e18;
  }
  ll mid = l + (r-l)/2;
  ll val1 = query(l , mid , 2*i , a, b);
  ll val2 = query(mid+1, r , 2*i+1, a, b);
  return max(val1 , val2);
}
 
 
ll update(ll l ,ll r , ll i, ll k, ll val){
  if(l == r && l == k){
    seg[i] = val;
    return seg[i];
  }
  if( l > k || r < k){
    return seg[i];
  }
  ll mid = l + (r-l)/2;
  ll val1 = update(l , mid , 2*i , k , val);
  ll val2 = update(mid+1, r , 2*i+1, k ,val);
  return seg[i] = max(val1 , val2);
}



bool isancestor(ll u, ll v){
    if(u == v){return 1;}
    if((timerin[u] < timerin[v]) && (timerout[u] > timerout[v] )){return 1;} 
    return 0;
}

ll lca(ll a, ll b, vt<vt<ll>>&up){
    if(isancestor(a,b)){return a;}
    else if(isancestor(b, a)){return b;}
    repr(i , up.size()-1, 0){
        if(!isancestor(up[i][a] , b)){
           a = up[i][a];
        }
    }
    return up[0][a];
}

void dfs(ll st, ll p , vt<vt<ll>>& g, vt<ll>&size, vt<vt<ll>>&up, vt<ll>&heavy , vt<ll>&depth){
    up[0][st] = p;
    depth[st] = depth[p]+1 ;
    parent[st] = p;
    for(ll i =  1 ; i<up.size(); i++){
        up[i][st] = up[i-1][up[i-1][st]];
    }
    size[st] += 1;
    timerin[st] = tim++;
    ll curr_max = 0;
    for(auto & x : g[st]){
        if(x == p){continue;}
        dfs(x, st, g, size, up, heavy, depth);
        size[st] += size[x];
        if(size[x] > curr_max){
            curr_max = x;
            heavy[st] = x;
        }
    }
    timerout[st] = tim++;
}

void decompose(ll st, ll p, ll h, vt<ll>&head, vt<ll>&heavy, vt<vt<ll>>&g){
    head[st] = h; labels[st] = label++; labelsr[label-1] = st;
    if(heavy[st] != -1){
       decompose(heavy[st] , st, h, head, heavy,g);
    }
    for(auto & x : g[st]){
        if(x == p || heavy[st] == x){continue;}
        decompose(x, st, x, head, heavy, g);
    }
}

ll queryhld(ll a , ll b, vt<ll>&depth, vt<ll>&head){
    ll res = 0;
    while(head[a] != head[b]){
        if(depth[head[a]] > depth[head[b]]){
            swap(a, b);
        }
        ll curr_max = query(0 , label - 1,1,labels[head[b]] , labels[b]);
        res = max(res, curr_max);
        b = parent[head[b]];
    }
    if(depth[a] > depth[b]){
        swap(a, b);
    }
    ll last_max = query(0 , label-1 , 1 ,labels[a], labels[b]);
    res = max(res, last_max);
    return res;

}



void solve(){ 
ll n ,q;
cin>>n>>q;
vt<ll>v(n+1);
rep(i , 0 , n){
    cin>>v[i+1];
}

timerin.resize(n+1) ; timerout.resize(n+1) ; labels.resize(n+1) ; labelsr.resize(n+1) ; parent.resize(n+1) ;
seg.resize(4*(n+1));

vt<vt<ll>>g(n+1);
rep(i , 0 , n-1){
    ll u, v; cin>>u>>v;
    g[u].push_back(v);
    g[v].push_back(u);
}

ll N = ceil((double)log2(n));
vt<vt<ll>>up(N +1 , vt<ll>(n+1,0));
vt<ll>size(n+1 , 0), heavy(n+1 , -1), depth(n+1 , 0), head(n+1 , 0);
dfs(1 , 1 ,g, size, up, heavy, depth);
decompose(1 , 1 , 1 , head, heavy,g);
build(0, label-1 , 1, v );

while(q--){
    ll t;
    cin>>t;
    if(t == 1){
    ll s, x;
    cin>>s>>x;
    v[s] = x;
    update(0 , label-1 , 1 , labels[s], x );
    }
    else {
    ll a, b;
    cin>>a>>b;
    ll lcaAB = lca(a,b, up);
    ll left = queryhld(lcaAB , a , depth, head);
    ll right = queryhld(lcaAB, b , depth, head);
    cout << max(left, right)<<"\n";
    }
}

}


int main(){
    ff();
    // ll t;
    // cin>>t;
    // while(t--){
    solve();
    // }
    return 0;
}
